// @ts-check

const createSW = require('./lib/webpack_child_process');

/*
    получаем параметры,
    получаем список файлов по регулярке из параметра,
    сохраняем список фалов для кэша
    запускаем компайлер для sw скрипта
    добавляем в sw список файлов для кэширования и версию
    компайлер сохраняет итоговый файл sw
*/

const PLUGIN_NAME = 'CustomPwaWebpackPlugin';

/** @typedef {import("webpack/lib/Compiler")} Compiler */

class CustomPwaWebpackPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler Webpack Compiler
     * @returns {void}
     */
    apply(compiler) {
        const self = this;

        const runAction = (compilation, callback) => {
            compilation.chunks.forEach(function(chunk) {
                // Explore each asset filename generated by the chunk:
                // chunk.files.forEach(function(filename) {
                //     var source = compilation.assets[filename].source();
                //     debugger;
                // });
                // запускаем дочерний процесс, по сборке sw передавая ему список файлов
            });
            callback();
        };


        if (compiler.hooks) {
            compiler.hooks
            // .afterEmit
            .emit
            .tapAsync(PLUGIN_NAME, runAction);
        } else {
            compiler.plugin('after-emit', runAction);
        }
    }

    isHotUpdateCompilation(assets) {
        return assets.js.length && assets.js.every(name => /\.hot-update\.js$/.test(name));
    }
}


module.exports = CustomPwaWebpackPlugin;
