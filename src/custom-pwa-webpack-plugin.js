// @ts-check

/*
    получаем параметры,
    получаем список файлов по регулярке из параметра,
    сохраняем список фалов для кэша
    запускаем компайлер для sw скрипта
    добавляем в sw список файлов для кэширования и версию
    компайлер сохраняет итоговый файл sw
*/

const PLUGIN_NAME = 'CustomPwaWebpackPlugin';

/** @typedef {import("webpack/lib/Compiler")} Compiler */

class CustomPwaWebpackPlugin {
    /**
     * Apply the plugin
     * @param {Compiler} compiler Webpack Compiler
     * @returns {void}
     */
    apply(compiler) {
        // const allChunks = compiler.hooks.compilation.getStats().toJson(chunkOnlyConfig).chunks;
        // compiler.hooks. compilation.assets
        (compiler.hooks ? compiler.hooks.make.tapAsync.bind(compiler.hooks.make, PLUGIN_NAME) : compiler.plugin.bind(compiler, 'make'))((compilation, callback) => {
            // Explore each chunk (build output):
            debugger;
            compilation.chunks.forEach(function(chunk) {
                // Explore each module within the chunk (built inputs):
                chunk.forEachModule(function(module) {
                    // Explore each source file path that was included into the module:
                    module.fileDependencies.forEach(function(filepath) {
                        // we've learned a lot about the source structure now...
                    });
                });

                // Explore each asset filename generated by the chunk:
                chunk.files.forEach(function(filename) {
                    // Get the asset source for each file generated by the chunk:
                    var source = compilation.assets[filename].source();
                });
            });

            callback();
        });
    }
}


module.exports = CustomPwaWebpackPlugin;
